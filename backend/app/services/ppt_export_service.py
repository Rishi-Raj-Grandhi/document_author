# app/services/ppt_export_service.py

from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.enum.text import PP_PARAGRAPH_ALIGNMENT
from pptx.dml.color import RGBColor
from io import BytesIO
import re
from typing import Dict, Any, List


def _apply_rich_text(run, text: str):
    """Parse and apply simple markdown styles like bold, italic, underline."""
    if not text:
        return

    patterns = [
        (r"\*\*(.*?)\*\*", "bold"),        # **bold**
        (r"__(.*?)__", "bold"),            # __bold__
        (r"\*(.*?)\*", "italic"),          # *italic*
        (r"_(.*?)_", "italic"),            # _italic_
        (r"`(.*?)`", "code")               # `code`
    ]

    # Split text into segments
    parts = [text]
    for pattern, style in patterns:
        new_parts = []
        for part in parts:
            if isinstance(part, str):
                matches = list(re.finditer(pattern, part))
                if not matches:
                    new_parts.append(part)
                    continue
                pos = 0
                for m in matches:
                    if m.start() > pos:
                        new_parts.append(part[pos:m.start()])
                    new_parts.append((m.group(1), style))
                    pos = m.end()
                if pos < len(part):
                    new_parts.append(part[pos:])
            else:
                new_parts.append(part)
        parts = new_parts

    # Apply style to PPTX run objects
    for part in parts:
        if isinstance(part, tuple):
            content, style = part
            r = run.text_frame.add_paragraph().add_run()
            r.text = content
            if style == "bold":
                r.font.bold = True
            elif style == "italic":
                r.font.italic = True
            elif style == "code":
                r.font.name = "Consolas"
                r.font.size = Pt(14)
                r.font.color.rgb = RGBColor(80, 80, 80)
        else:
            r = run.text_frame.add_paragraph().add_run()
            r.text = part


def export_to_ppt(presentation_data: Dict[str, Any]) -> BytesIO:
    """
    Converts structured PPT JSON (from PptService) into an actual .pptx file.
    """

    prs = Presentation()

    topic = presentation_data.get("topic", "Untitled Presentation")
    slides_data = presentation_data.get("slides", [])

    # ---------------------------------------------------------
    # TITLE SLIDE
    # ---------------------------------------------------------
    title_slide_layout = prs.slide_layouts[0]  # Title layout
    slide = prs.slides.add_slide(title_slide_layout)

    title = slide.shapes.title
    subtitle = slide.placeholders[1] if len(slide.placeholders) > 1 else None

    title.text = topic
    title.text_frame.paragraphs[0].font.size = Pt(40)
    title.text_frame.paragraphs[0].font.bold = True
    title.text_frame.paragraphs[0].alignment = PP_PARAGRAPH_ALIGNMENT.CENTER

    if subtitle:
        subtitle.text = "Generated by AI"
        subtitle.text_frame.paragraphs[0].font.size = Pt(20)
        subtitle.text_frame.paragraphs[0].alignment = PP_PARAGRAPH_ALIGNMENT.CENTER

    # ---------------------------------------------------------
    # CONTENT SLIDES
    # ---------------------------------------------------------
    bullet_slide_layout = prs.slide_layouts[1]  # Title + Content

    for slide_data in slides_data:
        slide = prs.slides.add_slide(bullet_slide_layout)

        # Slide Title
        shape = slide.shapes.title
        shape.text = slide_data.get("title", "Untitled Slide")

        # Bullets
        body_shape = slide.shapes.placeholders[1]
        text_frame = body_shape.text_frame
        text_frame.clear()

        bullets = slide_data.get("bullets", [])
        for bullet in bullets:
            p = text_frame.add_paragraph()
            p.text = bullet
            p.level = 0
            p.font.size = Pt(20)

    # ---------------------------------------------------------
    # OUTPUT BUFFER
    # ---------------------------------------------------------
    buffer = BytesIO()
    prs.save(buffer)
    buffer.seek(0)

    return buffer
